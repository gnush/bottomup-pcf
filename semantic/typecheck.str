module typecheck

imports
	include/TypedLambda
	trans/util

signature constructors
	CEq : Type * Type -> Constraint
	TVar     : STRING -> Type
	
rules
	foldtest: e -> <foldr(!0, \ (x, xs) -> xs \)> [1, 2, 3]
	
	foldtypeinfer: (t, []) -> t
	foldtypeinfer: (t, [(x, t')|mgu]) -> <foldtypeinfer> (t1, mgu)
		with t1 := <tSubst> (x, t, t')
	
	typeinfer: Module(x, e*) -> <map(\ (t, c, b, mgu) -> 
									<foldtypeinfer> (t, mgu)
	 							\)> t*
		with
			t* := <map(typeinfer)> e*
	typeinfer: e -> (t, c', bindings', mgu)
		with (t, c, bindings) := <infer> (e, []);
			 c'        := <nub> c;
			 bindings' := <nub> bindings;
			 (_, mgu)  := <unify> (c', [])

	infer: (True(), c)      -> (Bool(), c, [])
	infer: (False(), c)     -> (Bool(), c, [])
	infer: (Not(e), c)      -> (Bool(), c'', bindings)
		with (t', c', bindings) := <infer> (e, c);
			 c''                := <unions> [c, c', [CEq(Bool(), t')]]
	infer: (And(e1, e2), c) -> (Bool(), c', bindings)
		with (t1, c1, bindings1) := <infer> (e1, c);
			 (t2, c2, bindings2) := <infer> (e2, c);
			 bindings := <union> (bindings1, bindings2);
			 isect    := <isect> (bindings1, bindings2);
			 c'       := <unions> [c, c1, c2, [CEq(Bool(), t1), CEq(Bool(), t2)], <mk-bindings> (isect, [])]
	infer: (Num(_), c)      -> (TNum(), c, [])
	infer: (Add(e1, e2), c) -> (TNum(), c', bindings)
		with (t1, c1, bindings1) := <infer> (e1, c);
			 (t2, c2, bindings2) := <infer> (e2, c);
			 bindings := <union> (bindings1, bindings2);
			 isect    := <isect> (bindings1, bindings2);
			 c'       := <unions> [c, c1, c2, [CEq(TNum(), t1), CEq(TNum(), t2)], <mk-bindings> (isect, [])]
	infer: (Gt(e1, e2), c)  -> (Bool(), c', bindings)
		with (t1, c1, bindings1) := <infer> (e1, c);
			 (t2, c2, bindings2) := <infer> (e2, c);
			 bindings := <union> (bindings1, bindings2);
			 isect    := <isect> (bindings1, bindings2);
			 c'       := <unions> [c, c1, c2, [CEq(TNum(), t1), CEq(TNum(), t2)], <mk-bindings> (isect, [])]
	infer: (Cond(cond, then, else), c) -> (t2, c', bindings)
		with (t1, c1, bindings1) := <infer> (cond, c);
			 (t2, c2, bindings2) := <infer> (then, c);
			 (t3, c3, bindings3) := <infer> (else, c);
			 bindings := <unions> [bindings1, bindings2, bindings3];
			 isect    := <isect> (<isect> (bindings1, bindings2), bindings3) ;
			 c'       := <unions> [c, c1, c2, [CEq(Bool(), t1), CEq(t2, t3)], <mk-bindings> (isect, [])]
	infer: (Var(x), c)      -> (ty, c, [(x,ty)])
		with ty := TVar(<newname> "T")
	infer: (Abs(x, t, e), c) -> (Function(t, t'), c'', bindings')
		with (t', c', bindings) := <infer> (e, c);
			 bindings' := [(x, t)|bindings];
		     c''       := <unions> [c, c', <mk-bindings> (bindings', [])]
	infer: (App(e1, e2), c)  -> (t', c', bindings)
		with (t1, c1, bindings1) := <infer> (e1, c);
			 (t2, c2, bindings2) := <infer> (e2, c);
			 bindings := <union> (bindings1, bindings2);
			 isect    := <isect> (bindings1, bindings2);
			 t' := TVar(<newname> "T");
			 c' := <unions> [c, c1, c2, [CEq(t1, Function(t2, t'))], <mk-bindings> (isect, [])]

	//test-bindings: e -> <mk-bindings> ([("x", "T"), ("y", "T1"), ("x", "T2"), ("x", "T3"), ("y", "T4")], [])
	// -> [T = T2, T = T3, T2 = T3, T1 = T4]

	//mk-bindings: (bindings, constraints) -> constraints
	mk-bindings: ([], c) -> c
	mk-bindings: ([(x, t)|bs], c) -> <mk-bindings> (bs, c'')
		with c'  := <filter(?(x, _) ; \ (_, t') -> CEq(t, t') \)> bs;
		     c'' := <union> (c, c') 

	// solve: c -> <unify> (c, []) 
	solve: e -> (t, mgu)
		with (t, c, b) := <typeinfer> e;
			 (c', mgu) := <unify> (c, []) <+ !([], []) ; <error> ["Typecheck Failed for ", e] 


  // (x + 1) + ((\y. 1) x)

	// robinson: trivial, decompose, clash, orient, occur, varibale elimination
	//unify: (cs, mgu) -> (cs', mgu')
	unify: ([CEq(t, t)|cs], mgu) -> <unify> (cs, mgu) //trivial
	
	unify: ([CEq(Function(t1, t1'), Function(t2, t2'))|cs], mgu) -> <unify> (cs', mgu) // decompose 
		with cs' := <concat> [[CEq(t1, t2), CEq(t1', t2')], cs]
	
	unify: ([CEq(Bool(), Function(_, _))|cs], mgu) -> <fail> // clash
	unify: ([CEq(Function(_, _), Bool())|cs], mgu) -> <fail>
	unify: ([CEq(TNum(), Bool())|cs], mgu)  -> <fail>
	unify: ([CEq(Bool(), TNum())|cs], mgu)  -> <fail>
	unify: ([CEq(Function(_, _), TNum())|cs], mgu)  -> <fail>
	unify: ([CEq(TNum(), Function(_, _))|cs], mgu)  -> <fail>
	
	unify: ([CEq(t, TVar(x))|cs], mgu) -> <unify> ([CEq(TVar(x), t)|cs], mgu) // orient
	
	unify: ([CEq(TVar(x), t)|cs], mgu) -> <if <occurs> (x, t)
											then fail // x occurs in t
											else <unify> (cs', mgu') end> // variable elimination
		with cs'  := <map(\ CEq(t1, t2) -> CEq(<tSubst> (x, t1, t), <tSubst> (x, t2, t)) \)> cs; //map subst over cs
		     mgu1 := <map(\ (y, t1) -> (y, <tSubst> (x, t1, t)) \)> mgu; //map subst over mgu
		     mgu' := [(x, t)|mgu]
	
	unify: ([], mgu) -> ([], mgu)
	
	// if var occurs in term true, else false 
	occurs: (var, Bool())          -> <fail>
	occurs: (var, TNum())          -> <fail>
	occurs: (var, TVar(var))       -> <id>
	occurs: (var, TVar(_))         -> <fail>
	occurs: (var, Function(t, t')) -> <if <occurs> (var, t)
										then id
										else <occurs> (var, t') end>

	// substitute x in t with t'
	tSubst: (x, Bool(), t')           -> Bool()
	tSubst: (x, TNum(), t')           -> TNum()
	tSubst: (x, Function(t1, t2), t') -> Function(t1', t2')
		with t1' := <tSubst> (x, t1, t');
			 t2' := <tSubst> (x, t2, t')
	tSubst: (x, TVar(x), t')          -> t'
	tSubst: (x, TVar(y), t')          -> TVar(y)

	// wrong, unifing type and not terms
	// occurs: (var, True())       -> <fail>
	// occurs: (var, False())      -> <fail>
	// occurs: (var, Not(e))       -> <occurs> (var, e)
	// occurs: (var, And(e1, e2))  -> <if <occurs> (var, e1) then id else <occurs> (var, e2) end>
	// occurs: (var, Var(var))     -> <id>
	// occurs: (var, App(e1, e2))  -> <if <occurs> (var, e1) then id else <occurs> (var, e2) end>
	// occurs: (var, Abs(x, t, e)) -> <occurs> (var, e)  // meta variable names are fresh 