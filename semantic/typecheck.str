module typecheck

imports
	include/TypedLambda
	trans/util

signature constructors
	CEq : Type * Type -> Constraint
	TVar     : STRING -> Type
	
	B : ID * TYPE -> Binding
	
rules
    main = io-wrap(types)
    
    foldtest: e -> <foldr(!0, \ (x, xs) -> <add> (x, xs) \)> [1, 2, 3]
    
    // applies an mgu to a type
    // (t, mgu) -> t
    app_mgu: (t, []) -> t
    app_mgu: (t, [(x, t')|mgu]) -> <app_mgu> (t1, mgu)
        where t1 := <tSubst> (x, t, t')
    app_mgu = debug(!"app_mgu: "); fail

    bu: Module(x, e*) -> <map(bu)> e*
    bu = bottomup(try(generateConstraints))

    types: Module(x, e*) -> <map(\ (_, _, _, _, t) -> t\)> t*
        where t* := <map(typeinfer)> e*
    
    type: e -> t
        where (_, _, _, _, t) := <typeinfer> e

    typeinfer: Module(x, e*) -> t*
        where t* := <map(typeinfer)> e*
    typeinfer: e -> (t, c, b, mgu, <app_mgu> (t, mgu))
        where (t, c, b) := <bottomup(try(repeat(generateConstraints)))> e;
              mgu       := <solveConstraints> c
    typeinfer = debug(!"typeinfer: "); fail

    gen = bottomup(try(generateConstraints))

    // top down typecheck for reference
    topType: e -> <typecheck> (e, [])
    
    testtt: e -> <typecheck> (And(Var("x"),Var("y")),[("y",Bool()),("x",Bool())])
    testttt: e -> <typecheck> (Var("x"), ["x", Bool()])
    
    typecheck: Module(x, e*) -> <map(\ e -> <typecheck> (e, []) \)> e*
    typecheck: (True(), ctx) -> Bool()
    typecheck: (False(), ctx) -> Bool()
    typecheck: (Not(e), ctx) -> <if equal(|Bool(), t)
                                    then Bool()
                                    else <concat-strings> ["Not: argument must be of type bool but was", t] end>
        where t := <typecheck> (e, ctx)
    typecheck: (And(e1, e2), ctx) -> <if and(equal(|t1, t2), equal(|t1, Bool()))
                                        then Bool()
                                        else !"And: argument types must be bool but was " end>
        where t1 := <typecheck> (e1, ctx);
              t2 := <typecheck> (e2, ctx)
    typecheck: (Num(_), ctx) -> TNum()
    typecheck: (Add(e1, e2), ctx) -> <if and(equal(|t1, t2), equal(|t1, TNum()))
                                        then TNum()
                                        else <concat-strings> ["Add: argument types must be num but was", t1, t2] end>
        where t1 := <typecheck> (e1, ctx);
              t2 := <typecheck> (e2, ctx)
    typecheck: (Gt(e1, e2), ctx) -> <if and(equal(|t1, t2), equal(|t1, TNum()))
                                        then Bool()
                                        else <concat-strings> ["Gt: argument types must be num but was ", t1, t2] end>
        where t1 := <typecheck> (e1, ctx);
              t2 := <typecheck> (e2, ctx)
    typecheck: (Cond(cond, then, else), ctx) -> <if equal(|tCond, Bool())
                                                    then if equal(|tThen, tElse)
                                                            then !tThen
                                                            else <concat-strings> ["types of then and else branch do not match: ", tThen, tElse]
                                                                end
                                                    else <concat-strings> ["type of condition must be bool but was", tCond] end>
        where tCond := <typecheck> (cond, ctx);
              tThen := <typecheck> (then, ctx);
              tElse := <typecheck> (else, ctx)
    typecheck: (Var(x), ctx) -> "foo" //<typecheck> (And(Var("x"),Var("y")),[("y",Bool()),("x",Bool())])
    typecheck: (Abs(x, tParam, e), ctx) -> Function(tParam, tRet)
        where tRet := <typecheck> (e, [(x, tParam)|ctx])
    typecheck: (App(e1, e2), ctx) -> <if equal(|t1, t3) then !t2 else fail end>
        where Function(t1, t2) := <typecheck> (e1, ctx);
              t3 := <typecheck> (e2, ctx)
    typecheck: (Fix(f, t, e), ctx) -> t
        where t1 := <typecheck> (e, [(f, t)|ctx])
    typecheck: (Let(x, t, e1, e2), ctx) -> <if equal(|t, t1) then !t2 else fail end>
        where t1 := <typecheck> (e1, ctx);
              t2 := <typecheck> (e2, [(x, t)|ctx])
    typecheck = debug(!"typecheck: "); fail
        
    generateConstraints: True() -> (Bool(), [], [])
    generateConstraints: False() -> (Bool(), [], [])
    generateConstraints: Num(_) -> (TNum(), [], [])
    generateConstraints: Not((t, c, b)) -> (Bool(), <nub> [CEq(t, Bool())|c], b)
    generateConstraints: And((t1, c1, b1), (t2, c2, b2)) -> (Bool(), c', b)
        where b     := <bUnion> (b1, b2); 
              c     := <unions> [c1, c2, [CEq(Bool(), t1), CEq(Bool(), t2)], <isectConstraints> (b1, b2)];
              c'    := <nub> c
    generateConstraints: Add((t1, c1, b1), (t2, c2, b2)) -> (TNum(), c', b)
        where b     := <bUnion> (b1, b2); 
              c     := <unions> [c1, c2, [CEq(TNum(), t1), CEq(TNum(), t2)], <isectConstraints> (b1, b2)];
              c'    := <nub> c
    generateConstraints: Gt((t1, c1, b1), (t2, c2, b2)) -> (Bool(), c', b)
	    where b     := <bUnion> (b1, b2); 
	              c     := <unions> [c1, c2, [CEq(TNum(), t1), CEq(TNum(), t2)], <isectConstraints> (b1, b2)];
	              c'    := <nub> c
	generateConstraints: Cond((tCond, cCond, bCond),
	                          (tThen, cThen, bThen),
	                          (tElse, cElse, bElse)) -> (tThen, c', b)
        where b  := <bUnion> (bCond, <bUnion> (bThen, bElse));
              c  := <unions> [cCond, cThen, cElse
                             ,[CEq(Bool(), tCond), CEq(tThen, tElse)]
                             ,<isectConstraints> (bCond, <isectConstraints> (bThen, bElse))];
              c' := <nub> c
    generateConstraints: Var(x) -> (ty, [], [B(x, ty)])
        where ty := TVar(<newname> "T")
    generateConstraints: App((t1, c1, b1), (t2, c2, b2)) -> (t, c', b)
        where t  := TVar(<newname> "T");
              b  := <bUnion> (<union> (b1, b2));
              c  := <unions> [c1, c2, [CEq(t1, Function(t2, t))], <isectConstraints> (b1, b2)];
              c' := <nub> c
    generateConstraints: Abs(x, t, (t', c, b)) -> (Function(t, t'), <concat> [c, <isectConstraints> ([B(x, t)], b)], <filter(not(?(x, _)))> b)
    generateConstraints: Fix(x, t, (t', c, b)) -> (t, <concat> [c, <isectConstraints> ([B(x, t)], b)], <filter(not(?(x, _)))> b)
    generateConstraints: Let(x, t, (t1, c1, b1), (t2, c2, b2)) -> (t2, c', b')
        where b  := <bUnion> (b1, b2);
              b' := <filter(not(?(x, _)))> b;
              c  := <unions> [c1, c2, [CEq(t, t1)], <isectConstraints> ([B(x, t)|b1], b2)];
              c' := <nub> c 

    // (type, constraints) -> mgu
    solveConstraints: c -> mgu
       where (_, mgu) := <unify> (c, [])
    solveConstraints = debug(!"solveConstraints: "); fail

    // robinson: trivial, decompose, clash, orient, occur, varibale elimination
    //unify: (cs, mgu) -> (cs', mgu')
    unify: ([CEq(t, t)|cs], mgu) -> <unify> (cs, mgu) //trivial

    unify: ([CEq(Function(t1, t1'), Function(t2, t2'))|cs], mgu) -> <unify> (cs', mgu) // decompose 
        where cs' := <concat> [[CEq(t1, t2), CEq(t1', t2')], cs]

    // is there a way to check for equality of constructors?
    unify: ([CEq(Bool(), Function(_, _))|cs], mgu) -> <fail> // clash
    unify: ([CEq(Function(_, _), Bool())|cs], mgu) -> <fail>
    unify: ([CEq(TNum(), Bool())|cs], mgu)  -> <fail>
    unify: ([CEq(Bool(), TNum())|cs], mgu)  -> <fail>
    unify: ([CEq(Function(_, _), TNum())|cs], mgu)  -> <fail>
    unify: ([CEq(TNum(), Function(_, _))|cs], mgu)  -> <fail>

    unify: ([CEq(t, TVar(x))|cs], mgu) -> <unify> ([CEq(TVar(x), t)|cs], mgu) // orient

    unify: ([CEq(TVar(x), t)|cs], mgu) -> <if <occurs> (x, t)
                                            then fail // x occurs in t
                                            else <unify> (cs', mgu') end> // variable elimination
        where cs'  := <map(\ CEq(t1, t2) -> CEq(<tSubst> (x, t1, t), <tSubst> (x, t2, t)) \)> cs; //map subst over cs
              mgu1 := <map(\ (y, t1) -> (y, <tSubst> (x, t1, t)) \)> mgu; //map subst over mgu
              mgu' := [(x, t)|mgu1]

    unify: ([], mgu) -> ([], mgu)
    unify = debug(!"unify"); fail
    
    //
    unify1: ([CEq(t, t)|cs], mgu) -> <unify1> (cs, mgu)
    unify1: ([CEq(Function(t1, t1'), Function(t2, t2'))|cs], mgu) -> <unify1> (cs', mgu)
        where cs' := <concat> [[CEq(t1, t2), CEq(t1', t2')], cs]
    // clash checks
    // fail
    unify1: ([CEq(t, TVar(x))|cs], mgu) -> <unify1> ([CEq(TVar(x), t)|cs], mgu)
    unify1: ([CEq(TVar(x), t)|cs], mgu) -> <if <occurs> (x, t)
                                            then ![CEq(TVar(x), t)|cs] // x occurs in t  fail or not so bad?
                                            else <unify1> (cs', mgu') end> // variable elimination
        where cs'  := <map(\ CEq(t1, t2) -> CEq(<tSubst> (x, t1, t), <tSubst> (x, t2, t)) \)> cs; //map subst over cs
              mgu1 := <map(\ (y, t1) -> (y, <tSubst> (x, t1, t)) \)> mgu; //map subst over mgu
              mgu' := [(x, t)|mgu1]
	
    // if var occurs in term true, else false 
    occurs: (var, Bool())          -> <fail>
    occurs: (var, TNum())          -> <fail>
    occurs: (var, TVar(var))       -> <id>
    occurs: (var, TVar(_))         -> <fail>
    occurs: (var, Function(t, t')) -> <if <occurs> (var, t)
                                        then id
                                        else <occurs> (var, t') end>
    // occurs = debug(!"occurs: ")

    // substitute x in t with t'
    tSubst: (x, Bool(), t')           -> Bool()
    tSubst: (x, TNum(), t')           -> TNum()
    tSubst: (x, Function(t1, t2), t') -> Function(t1', t2')
        where t1' := <tSubst> (x, t1, t');
              t2' := <tSubst> (x, t2, t')
    tSubst: (x, TVar(x), t')          -> t'
    tSubst: (x, TVar(y), t')          -> TVar(y)
    tSubst = debug(!"tSubst: "); fail


    //[B("x", "T1"), B("x", "T1123"), B("y", "T2"), B("y", "T1234")] -> [B("x", "T1"), B("y", "T2")]
    bUnion: (xs, ys) -> <bUnion> (<union> (xs, ys))	
    bUnion: [] -> []
    bUnion: [B(x, t)|bs] -> [B(x, t)|<bUnion> bs']
        where bs' := <filter(not(?(x, _)))> bs
    bUnion = debug(!"bUnion: "); fail
	
    // [B("x", "T1"), B("y", "T2")] [B("x", "T3")] -> [T1 = T3]
    // [B("x", "T1"), B("y", "T2"), B("x", "T3")] [B("x", "T4"), B("y", "T5")] -> [T1 = T4, T2 = T5, T3 = T4]
    //testtt: e -> (<bIsect> ([B("x", "T1"), B("y", "T2")], [B("x", "T3")]), <bIsect> ([B("x", "T1"), B("y", "T2"), B("x", "T3")], [B("x", "T4"), B("y", "T5")]))
    isectConstraints: ([], ys) -> []
    isectConstraints: ([B(x, t)|xs], ys) -> <union> (c, <isectConstraints> (xs, ys))
        where c := <filter(?B(x, _) ; \ (_, t') -> CEq(t, t') \)> ys
    isectConstraints = debug(!"isectConstraints: "); fail
    
    
// (\x : Bool -> Bool. x) (\x : Bool. x)
//     
// generates
//     
// ( TVar("T6")
// , [ CEq(Function(Bool(), Bool()), TVar("T4"))
//   , CEq(Bool(), TVar("T5"))
//   , CEq(
//       Function(Function(Bool(), Bool()), TVar("T4"))
//     , Function(Function(Bool(), TVar("T5")), TVar("T6"))
//     )
//   , CEq(TVar("T4"), TVar("T5"))
// ]
// , [B("x", TVar("T4"))]
// )
// 
// and CEq(TVar("T4"), TVar("T5")) is wrong
// 
// Var: (TVar("T4"),[],[B("x",TVar("T4"))])
// Abs: (Function(Function(Bool,Bool),TVar("T4")),[CEq(Function(Bool,Bool),TVar("T4"))],[B("x",TVar("T4"))])
// Var: (TVar("T5"),[],[B("x",TVar("T5"))])
// Abs: (Function(Bool,TVar("T5")),[CEq(Bool,TVar("T5"))],[B("x",TVar("T5"))])
// App: (TVar("T6"),[CEq(Function(Bool,Bool),TVar("T4")),CEq(Bool,TVar("T5")),CEq(Function(Function(Bool,Bool),TVar("T4")),Function(Function(Bool,TVar("T5")),TVar("T6"))),CEq(TVar("T4"),TVar("T5"))],[B("x",TVar("T4"))])
// 
// remove vars from bindings in abs?