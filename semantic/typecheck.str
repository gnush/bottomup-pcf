module typecheck

imports
	include/TypedLambda

signature constructors
	CEq : Type * Type -> Constraint
	TVar     : STRING -> Type
	
	B : ID * TYPE -> Binding
	
rules
    main = io-wrap(types)
    
    foldtest: e -> <foldr(!0, \ (x, xs) -> <add> (x, xs) \)> [1, 2, 3]
    
    testt: e -> [<bUnion> (b1, <bUnion> (b2, b3)),
                 <union> (<isectConstraints> (b1, b2),
                          <isectConstraints> (b2, b3)),
                 <isectConstraints> (b1, b2, b3)]
        with b1 := [B("x", TVar("T1"))];
             b2 := [B("x", TVar("T2"))];
             b3 := [B("x", TVar("T3"))]
    
    // applies an mgu to a type
    // (t, mgu) -> t
    app_mgu: (t, []) -> t
    app_mgu: (t, [(x, t')|mgu]) -> <app_mgu> (t1, mgu)
        where t1 := <tSubst> (x, t, t')
    app_mgu = debug(!"app_mgu: "); fail

    bu: Module(x, e*) -> <map(bu)> e*
    bu = bottomup(try(generateConstraints))

    types: Module(x, e*) -> <map(\ (_, _, _, _, t) -> t\)> t*
        where t* := <map(typeinfer)> e*
    
    type: e -> t
        where (_, _, _, _, t) := <typeinfer> e

    typeinfer: Module(x, e*) -> t*
        where t* := <map(typeinfer)> e*
    typeinfer: e -> (t, c, b, mgu, <app_mgu> (t, mgu))
        where (t, c, b) := <bottomup(try(repeat(generateConstraints)))> e;
              mgu       := <solveConstraints> c
    typeinfer = debug(!"typeinfer: "); fail

    gen = bottomup(try(generateConstraints))
        
    generateConstraints: True() -> (Bool(), [], [])
    generateConstraints: False() -> (Bool(), [], [])
    generateConstraints: Num(_) -> (TNum(), [], [])
    generateConstraints: Not((t, c, b)) -> (Bool(), <nub> [CEq(t, Bool())|c], b)
    generateConstraints: And((t1, c1, b1), (t2, c2, b2)) -> (Bool(), c', b)
        where b     := <bUnion> (b1, b2); 
              c     := <unions> [c1, c2, [CEq(Bool(), t1), CEq(Bool(), t2)], <isectConstraints> (b1, b2)];
              c'    := <nub> c
    generateConstraints: Add((t1, c1, b1), (t2, c2, b2)) -> (TNum(), c', b)
        where b     := <bUnion> (b1, b2); 
              c     := <unions> [c1, c2, [CEq(TNum(), t1), CEq(TNum(), t2)], <isectConstraints> (b1, b2)];
              c'    := <nub> c
    generateConstraints: Gt((t1, c1, b1), (t2, c2, b2)) -> (Bool(), c', b)
	    where b     := <bUnion> (b1, b2); 
	              c     := <unions> [c1, c2, [CEq(TNum(), t1), CEq(TNum(), t2)], <isectConstraints> (b1, b2)];
	              c'    := <nub> c
	generateConstraints: Cond((tCond, cCond, bCond),
	                          (tThen, cThen, bThen),
	                          (tElse, cElse, bElse)) -> (tThen, c', b)
        where b  := <bUnion> (bCond, <bUnion> (bThen, bElse));
              c  := <unions> [cCond, cThen, cElse
                             ,[CEq(Bool(), tCond), CEq(tThen, tElse)]
                             ,<isectConstraints> (bCond, bThen, bElse)];
              c' := <nub> c
    generateConstraints: Var(x) -> (ty, [], [B(x, ty)])
        where ty := TVar(<newname> "T")
    generateConstraints: App((t1, c1, b1), (t2, c2, b2)) -> (t, c', b)
        where t  := TVar(<newname> "T");
              b  := <bUnion> (<union> (b1, b2));
              c  := <unions> [c1, c2, [CEq(t1, Function(t2, t))], <isectConstraints> (b1, b2)];
              c' := <nub> c
    generateConstraints: Abs(x, t, (t', c, b)) -> (Function(t, t'), <concat> [c, <isectConstraints> ([B(x, t)], b)], <filter(not(?(x, _)))> b)
    generateConstraints: Fix(x, t, (t', c, b)) -> (t, <concat> [c, <isectConstraints> ([B(x, t)], b)], <filter(not(?(x, _)))> b)
    generateConstraints: Let(x, t, (t1, c1, b1), (t2, c2, b2)) -> (t2, c', b')
        where b  := <bUnion> (b1, b2);
              b' := <filter(not(?(x, _)))> b;
              c  := <unions> [c1, c2, [CEq(t, t1)], <isectConstraints> ([B(x, t)|b1], b2)];
              c' := <nub> c 

    // (type, constraints) -> mgu
    solveConstraints: c -> mgu
       where (_, mgu) := <unify> (c, [])
    solveConstraints = debug(!"solveConstraints: "); fail

    // robinson: trivial, decompose, clash, orient, occur, varibale elimination
    //unify: (cs, mgu) -> (cs', mgu')
    unify: ([CEq(t, t)|cs], mgu) -> <unify> (cs, mgu) //trivial

    unify: ([CEq(Function(t1, t1'), Function(t2, t2'))|cs], mgu) -> <unify> (cs', mgu) // decompose 
        where cs' := <concat> [[CEq(t1, t2), CEq(t1', t2')], cs]

    // is there a way to check for equality of constructors?
    unify: ([CEq(Bool(), Function(_, _))|cs], mgu) -> <fail> // clash
    unify: ([CEq(Function(_, _), Bool())|cs], mgu) -> <fail>
    unify: ([CEq(TNum(), Bool())|cs], mgu)  -> <fail>
    unify: ([CEq(Bool(), TNum())|cs], mgu)  -> <fail>
    unify: ([CEq(Function(_, _), TNum())|cs], mgu)  -> <fail>
    unify: ([CEq(TNum(), Function(_, _))|cs], mgu)  -> <fail>

    unify: ([CEq(t, TVar(x))|cs], mgu) -> <unify> ([CEq(TVar(x), t)|cs], mgu) // orient

    unify: ([CEq(TVar(x), t)|cs], mgu) -> <if <occurs> (x, t)
                                            then fail // x occurs in t
                                            else <unify> (cs', mgu') end> // variable elimination
        where cs'  := <map(\ CEq(t1, t2) -> CEq(<tSubst> (x, t1, t), <tSubst> (x, t2, t)) \)> cs; //map subst over cs
              mgu1 := <map(\ (y, t1) -> (y, <tSubst> (x, t1, t)) \)> mgu; //map subst over mgu
              mgu' := [(x, t)|mgu1]

    unify: ([], mgu) -> ([], mgu)
    unify = debug(!"unify"); fail
    
    //
//     unify1: ([CEq(t, t)|cs], mgu) -> <unify1> (cs, mgu)
//     unify1: ([CEq(Function(t1, t1'), Function(t2, t2'))|cs], mgu) -> <unify1> (cs', mgu)
//         where cs' := <concat> [[CEq(t1, t2), CEq(t1', t2')], cs]
//     // clash checks
//     // fail
//     unify1: ([CEq(t, TVar(x))|cs], mgu) -> <unify1> ([CEq(TVar(x), t)|cs], mgu)
//     unify1: ([CEq(TVar(x), t)|cs], mgu) -> <if <occurs> (x, t)
//                                             then ![CEq(TVar(x), t)|cs] // x occurs in t  fail or not so bad?
//                                             else <unify1> (cs', mgu') end> // variable elimination
//         where cs'  := <map(\ CEq(t1, t2) -> CEq(<tSubst> (x, t1, t), <tSubst> (x, t2, t)) \)> cs; //map subst over cs
//               mgu1 := <map(\ (y, t1) -> (y, <tSubst> (x, t1, t)) \)> mgu; //map subst over mgu
//               mgu' := [(x, t)|mgu1]
	
    // if var occurs in term true, else false 
    occurs: (var, Bool())          -> <fail>
    occurs: (var, TNum())          -> <fail>
    occurs: (var, TVar(var))       -> <id>
    occurs: (var, TVar(_))         -> <fail>
    occurs: (var, Function(t, t')) -> <if <occurs> (var, t)
                                        then id
                                        else <occurs> (var, t') end>
    // occurs = debug(!"occurs: ")

    // substitute x in t with t'
    tSubst: (x, Bool(), t')           -> Bool()
    tSubst: (x, TNum(), t')           -> TNum()
    tSubst: (x, Function(t1, t2), t') -> Function(t1', t2')
        where t1' := <tSubst> (x, t1, t');
              t2' := <tSubst> (x, t2, t')
    tSubst: (x, TVar(x), t')          -> t'
    tSubst: (x, TVar(y), t')          -> TVar(y)
    tSubst = debug(!"tSubst: "); fail

    // union of bindings and intersection of constraints in bindings
    // (bs, bs) -> (cs, bs)
//     merge: (bs1, bs2, bs3, cs) -> bs'
//         where bs' := <bUnion> (bs1, <bUnion> (bs2, bs3));
//               cs' := <unions> [cs, <isectConstraints> ()]  
// 
// <isectConstraints> (bCond, <isectConstraints> (bThen, bElse))

    //[B("x", "T1"), B("x", "T1123"), B("y", "T2"), B("y", "T1234")] -> [B("x", "T1"), B("y", "T2")]
    bUnion: (xs, ys) -> <bUnion> (<union> (xs, ys))	
    bUnion: [] -> []
    bUnion: [B(x, t)|bs] -> [B(x, t)|<bUnion> bs']
        where bs' := <filter(not(?B(x, _)))> bs
    bUnion = debug(!"bUnion: "); fail
	
    // [B("x", "T1"), B("y", "T2")] [B("x", "T3")] -> [T1 = T3]
    // [B("x", "T1"), B("y", "T2"), B("x", "T3")] [B("x", "T4"), B("y", "T5")] -> [T1 = T4, T2 = T5, T3 = T4]
    //testtt: e -> (<bIsect> ([B("x", "T1"), B("y", "T2")], [B("x", "T3")]), <bIsect> ([B("x", "T1"), B("y", "T2"), B("x", "T3")], [B("x", "T4"), B("y", "T5")]))
    isectConstraints: ([], ys) -> []
    isectConstraints: ([B(x, t)|xs], ys) -> <union> (c, <isectConstraints> (xs, ys))
        where c := <filter(?B(x, _) ; \ (_, t') -> CEq(t, t') \)> ys
        
    isectConstraints: (ys, zs) -> []
    isectConstraints: (xs, ys, zs) -> <unions> [<isectConstraints> (xs, ys),
                                                <isectConstraints> (ys, zs)]
    isectConstraints = debug(!"isectConstraints: "); fail