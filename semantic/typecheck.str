module typecheck

imports
	include/TypedLambda
	trans/util

signature constructors
	CEq : Type * Type -> Constraint
	// CBinding : STRING * Type -> Constraint
	// 
	// TUnbound : STRING -> Type
	TVar     : STRING -> Type
	
rules
	typeinfer: e -> (t, c')
		with (t, c) := <infer> (e, []);
			 c'     := <nub> c

	// (env, e, c) -> (t, c)
	// infer: (env, True(), c)      -> (Bool(), c)
	// infer: (env, False(), c)     -> (Bool(), c)
	// infer: (env, Not(e), c)      -> (Bool(), c'')
	// 	with (t', c') := <infer> (env, e, c);
	// 		 c''      := <concat> [c, c', [CEq(Bool(), t')]]
	// infer: (env, And(e1, e2), c) -> (Bool(), c')
	// 	with (t1, c1) := <infer> (env, e1, c);
	// 		 (t2, c2) := <infer> (env, e2, c);
	// 		 c'       := <concat> [c, c1, c2, [CEq(Bool(), t1), CEq(Bool(), t2)]]
	// infer: (env, Var(x), c)      -> (t, c)
	// 	with (var, t) := <if <elem(?(x, _))> env
	// 				then <fetch-elem(?(x, _))> env 
	// 				else !(x, TUnbound(x))
	// 					end>
	// infer: (env, Abs(x, t, e), c) -> (Function(t, t'), c'')
	// 	with env'     := <concat> [env, [(x, t)]];
	// 	     (t', c') := <infer> (env', e, c);
	// 	     c''      := <concat> [c, c', [CBinding(x, t)]]
	// infer: (env, App(e1, e2), c)  -> (t', c')
	// 	with (t1, c1) := <infer> (env, e1, c);
	// 		 (t2, c2) := <infer> (env, e2, c);
	// 		 t'       := TVar(<newname> "newType");
	// 		 c'       := <concat> [c, c1, c2, [CEq(t1, Function(t2, t'))]]
	infer: (True(), c)      -> (Bool(), c, [])
	infer: (False(), c)     -> (Bool(), c, [])
	infer: (Not(e), c)      -> (Bool(), c'', bindings)
		with (t', c', bindings) := <infer> (e, c);
			 c''                := <unions> [c, c', [CEq(Bool(), t')]]
	infer: (And(e1, e2), c) -> (Bool(), c', bindings)
		with (t1, c1, bindings1) := <infer> (e1, c);
			 (t2, c2, bindings2) := <infer> (e2, c);
			 bindings := <union> (bindings1, bindings2);
			 isect    := <isect> (bindings1, bindings2);
			 c'       := <unions> [c, c1, c2, [CEq(Bool(), t1), CEq(Bool(), t2)], <mk-bindings> (isect, [])]
	infer: (Var(x), c)      -> (ty, c, [(x,ty)]) where ty := TVar(<newname> "T")
	infer: (Abs(x, t, e), c) -> (Function(t, t'), c'', bindings')
		with (t', c', bindings) := <infer> (e, c);
			 bindings' := [(x, t)|bindings];
		     c''       := <unions> [c, c', <mk-bindings> (bindings', [])]
	infer: (App(e1, e2), c)  -> (t', c', bindings)
		with (t1, c1, bindings1) := <infer> (e1, c);
			 (t2, c2, bindings2) := <infer> (e2, c);
			 bindings := <union> (bindings1, bindings2);
			 isect    := <isect> (bindings1, bindings2);
			 t' := TVar(<newname> "T");
			 c' := <unions> [c, c1, c2, [CEq(t1, Function(t2, t'))], <mk-bindings> (isect, [])]

	//test-bindings: e -> <mk-bindings> ([("x", "T"), ("y", "T1"), ("x", "T2"), ("x", "T3"), ("y", "T4")], [])
	// -> [T = T2, T = T3, T2 = T3, T1 = T4]

	//mk-bindings: (bindings, constraints) -> constraints
	mk-bindings: ([], c) -> c
	mk-bindings: ([(x, t)|bs], c) -> <mk-bindings> (bs, c'')
		with c'  := <filter(?(x, _) ; \ (_, t') -> CEq(t, t') \)> bs;
		     c'' := <union> (c, c') 

	solve: c -> c


  // (x + 1) + ((\y. 1) x)

	// robinson: trivial, decompose, clash, orient, occur, varibale elimination
	//unify: (cs, mgu) -> (cs', mgu')
	unify: ([CEq(t, t)|cs], mgu) -> <unify> (cs, mgu) //trivial
	
	unify: ([CEq(Function(t1, t1'), Function(t2, t2'))|cs], mgu) -> <unify> (cs', mgu) // decompose 
		with cs' := <concat> [[CEq(t1, t2), CEq(t1', t2')], cs]
	
	unify: ([CEq(Bool(), Function(_, _))|cs], mgu) -> <fail> // clash
	unify: ([CEq(Function(_, _), Bool())|cs], mgu) -> <fail>
	
	unify: ([CEq(t, TVar(x))|cs], mgu) -> <unify> ([CEq(TVar(x), t)|cs], mgu) // orient
	
	unify: ([CEq(TVar(x), t)|cs], mgu) -> <if <occurs> (x, t)
											then fail // x occurs in t
											else <unify> (cs', mgu') end> // variable elimination
		with cs'  := cs; //map subst over cs
		     mgu1 := mgu; //map subst over mgu
		     mgu' := [(x, t)|mgu]
	
	unify: ([], mgu) -> ([], mgu)
	
	
	// eliminate TUnbound with CBinding before unification
	occurs: (var, Bool())          -> <fail>
	occurs: (var, TVar(var))       -> <id>
	occurs: (var, TVar(_))         -> <fail>
	occurs: (var, Function(t, t')) -> <if <occurs> (var, t)
										then id
										else <occurs> (var, t') end>

	// substitute x in t with t'
	subst: (x, Bool(), t')           -> Bool()
	subst: (x, Function(t1, t2), t') -> Function(t1', t2')
		with t1' := <subst> (x, t1, t');
			 t2' := <subst> (x, t2, t')
	subst: (x, TVar(x), t')          -> t'
	subst: (x, TVar(y), t')          -> TVar(y)

	// wrong, unifing typed and not terms
	// occurs: (var, True())       -> <fail>
	// occurs: (var, False())      -> <fail>
	// occurs: (var, Not(e))       -> <occurs> (var, e)
	// occurs: (var, And(e1, e2))  -> <if <occurs> (var, e1) then id else <occurs> (var, e2) end>
	// occurs: (var, Var(var))     -> <id>
	// occurs: (var, App(e1, e2))  -> <if <occurs> (var, e1) then id else <occurs> (var, e2) end>
	// occurs: (var, Abs(x, t, e)) -> <occurs> (var, e)  // meta variable names are fresh 